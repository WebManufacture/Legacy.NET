using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.IO.Ports;
using System.Threading;
using System.IO.Ports;

namespace MRS.Hardware.UART
{
    public enum ASCII : byte
    {
        NUL = 0x00,// Null= пустой. Всегда игнорировался. На перфолентах 1 представлялась отверстием= 0,//отсутствием отверстия. Поэтому пустые части перфоленты до начала и после конца сообщения состояли из таких символов. Сейчас используется во многих языках программирования как конец строки. (Строка понимается как последовательность символов.) В некоторых операционных системах NUL,//последний символ любого текстового файла.
        SOH = 0x01,// Start Of Heading= начало заголовка.
        STX = 0x02,// Start of Text= начало текста. Текстом называлась часть сообщения= предназначенная для печати. Адрес= контрольная сумма и т. д. входили или в заголовок= или в часть сообщения после текста.
        ETX = 0x03,//End of Text= конец текста. Здесь телетайп прекращал печатать. Использование символа Ctrl-C= имеющего код 03= для прекращения работы чего-то (обычно программы)= восходит ещё к тем временам.
        EOT = 0x04,//End of Transmission= конец передачи. В системе UNIX Ctrl-D= имеющий тот же код= означает конец файла при вводе с клавиатуры.
        ENQ = 0x05,//Enquire. Прошу подтверждения.
        ACK = 0x06,//Acknowledgement. Подтверждаю.
        BEL = 0x07,//Bell= звонок= звуковой сигнал. Сейчас тоже используется. В языках программирования C и C++ обозначается \a.
        BS = 0x08,//Backspace= возврат на один символ. Сейчас стирает предыдущий символ.
        TAB = 0x09,//Tabulation. Обозначался также HT,//Horizontal Tabulation= горизонтальная табуляция. Во многих языках программирования обозначается \t .
        LF = 0x0A,//Line Feed= перевод строки. Сейчас в конце каждой строчки текстового файла ставится либо этот символ= либо CR= либо и тот и другой (CR= затем LF)= в зависимости от операционной системы. Во многих языках программирования обозначается \n и при выводе текста приводит к переводу строки.
        VT = 0x0B,//Vertical Tab= вертикальная табуляция.
        FF = 0x0C,//Form Feed= новая страница.
        CR = 0x0D,//Carriage Return= возврат каретки. Во многих языках программирования этот символ= обозначаемый \r= можно использовать для возврата в начало строчки без перевода строки. В некоторых операционных системах этот же символ= обозначаемый Ctrl-M= ставится в конце каждой строчки текстового файла перед LF.
        SO = 0x0E,//Shift Out= измени цвет ленты (использовался для двуцветных лент; цвет менялся обычно на красный). В дальнейшем обозначал начало использования национальной кодировки.
        SI = 0x0F,//Shift In= обратно к Shift Out.
        DLE = 0x10,//Data Link Escape= следующие символы имеют специальный смысл.
        DC1 = 0x11,//Device Control 1= 1-й символ управления устройством,//включить устройство чтения перфоленты.
        DC2 = 0x12,//Device Control 2= 2-й символ управления устройством,//включить перфоратор.
        DC3 = 0x13,//Device Control 3= 3-й символ управления устройством,//выключить устройство чтения перфоленты.
        DC4 = 0x14,//Device Control 4= 4-й символ управления устройством,//выключить перфоратор.
        NAK = 0x15,//Negative Acknowledgment= не подтверждаю. Обратно к Acknowledgment.
        SYN = 0x16,//Synchronization. Этот символ передавался= когда для синхронизации было необходимо что-нибудь передать.
        ETB = 0x17,//End of Text Block= конец текстового блока. Иногда текст по техническим причинам разбивался на блоки.
        CAN = 0x18,//Cancel= отмена (того= что было передано ранее).
        EM = 0x19,//End of Medium= кончилась перфолента и т. д.
        SUB = 0x1A,//Substitute= подставить. Ставится на месте символа= значение которого было потеряно или испорчено при передаче. Сейчас Ctrl-Z используется как конец файла при вводе с клавиатуры в системах DOS и Windows. У этой функции нет никакой очевидной связи с символом SUB.
        ESC = 0x1B,//Escape. Следующие символы,//что-то специальное.
        FS = 0x1C,//File Separator= разделитель файлов.
        GS = 0x1D,//Group Separator= разделитель групп.
        RS = 0x1E,//Record Separator= разделитель записей.
        US = 0x1F,//Unit Separator= разделитель юнитов. То есть поддерживалось 4 уровня структуризации данных: сообщение могло состоять из файлов= файлы из групп= группы из записей= записи из юнитов.
        DEL = 0x7F,//Delete= стереть последний символ. Символом DEL= состоящим в двоичном коде из всех единиц= можно было забить любой символ. Устройства и программы игнорировали DEL так же= как NUL. Код этого символа происходит из первых текстовых процессоров с памятью на перфоленте: в них удаление символа происходило забиванием его кода дырочками (обозначавшими логические единицы).
    }


    public static class Binary
    {
        public const byte BIT_0 = 1;
        public const byte BIT_1 = 2;
        public const byte BIT_2 = 4;
        public const byte BIT_3 = 8;
        public const byte BIT_4 = 16;
        public const byte BIT_5 = 32;
        public const byte BIT_6 = 64;
        public const byte BIT_7 = 128;
    }
}
